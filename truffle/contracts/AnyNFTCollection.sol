// SPDX-License-Identifier: MIT
pragma solidity 0.8.19;

import "./ERC4907.sol";
import "./IAnyNFTCollection.sol";
import "../node_modules/@openzeppelin/contracts/utils/Counters.sol";
import "../node_modules/@openzeppelin/contracts/access/Ownable.sol";
import "./Utils.sol";

contract AnyNFTCollection is ERC4907, IAnyNFTCollection, Ownable{

    using Counters for Counters.Counter;

    Counters.Counter private tokenIds;

    // Renter address allowed to mint NFTs
    address public renter;

    // NFTs in collection generated by the renter and max
    Utils.Tool[]  tools;

    uint8 public constant MAX_TOOLS = 100;

    constructor(string memory _name, string memory _symbol, address _owner) ERC4907(_name,_symbol){
        renter = _owner;

        // Fill the first element of tools to match NFT tokenId
        Utils.Tool memory _tool0;
        _tool0.tokenID = 0;
        _tool0.serialID = 0;
        _tool0.title = "genesis";
        _tool0.description = "genesis";
        _tool0.tokenURI = "";
        _tool0.isAvailable = false; 
        tools.push(_tool0);
    }



/* ***********************************************
*   Events 
*********************************************** */
  /**
     * @dev Emitted when a renter add a tool to its NFT Collection.
     */
    event NFTCreated(address owner, uint tokenId, uint timestamp);
  
 /**
     * @dev Emitted when a renter add a tool to its NFT Collection.
     */
    event NFTBurned(address owner, uint tokenId, uint timestamp);
  


/* ***********************************************
*   Modifiers 
*********************************************** */
    /**
    * @dev Only renter can call
    */
    modifier onlyRenter(address _from) {
        require(renter == _from, "You are not the renter of that collection.");
        _;
    }
 
/* ***********************************************
*   Getters 
*********************************************** */
    function getTools() public view returns (Utils.Tool[] memory){
        return tools;
    }

    function getToolsByTokenID(uint _tokenId) public view returns (Utils.Tool memory){
        require(tokenIds.current() >= _tokenId, "Tool does not exist");
        for (uint i; i < tools.length; i++) {
            if(tools[i].tokenID == _tokenId){
                return tools[i];
            }
        }
        return tools[0];
    }

     function getNbTools() public view returns (uint){
        return tools.length;
    }

/* ***********************************************
*    mint / burn / rent / giveBack
*********************************************** */
   
    /**
    * @notice mint a tool NFT and add it to the array
    * @dev
    * Requirements: tokenURI, title and description can't be empty.
    * @return tokenIdof the token
    */
   function mint(string calldata _tokenURI, uint _serialId, string memory _title, string memory _description, address _from) external onlyRenter(_from)  returns (uint256) {
        require(tools.length < MAX_TOOLS, "Maximum number of tools reached");
        require(!Utils.isEqualString(_tokenURI,""), "token URI can't be empty");
        require(!Utils.isEqualString(_title,""), "title can't be empty");
        require(!Utils.isEqualString(_description,""), "description can't be empty");

        tokenIds.increment();
        uint newToolId = tokenIds.current();

         Utils.Tool memory _tool;
        _tool.tokenID = newToolId;
        _tool.serialID = _serialId;
        _tool.title = _title;
        _tool.description = _description;
        _tool.tokenURI = _tokenURI;
        _tool.isAvailable = true; 

        tools.push(_tool);
  

        _mint(renter, newToolId);
        _setTokenURI(newToolId, _tokenURI);

        //_from is the renter (cf modifiers)
        //To manage the delegation, _from delegate the approval to the contract
        //approve(msg.sender, newToolId);
        emit NFTCreated(renter,newToolId, block.timestamp );
        return newToolId;
    }


   
    function burn(uint256 _tokenId, address _from) external onlyRenter(_from) {
        require(tokenIds.current() >= _tokenId, "Tool does not exist");

        uint id;
         for (uint i; i < tools.length; i++) {
            if(tools[i].tokenID == _tokenId){
                id=i;
            }
        }
        
        delete tools[id];   
        _burn(_tokenId);
        emit NFTBurned(renter, _tokenId, block.timestamp );

    }


    function rentTool(uint _tokenId, address _to, uint64 _expires, address _from) external onlyRenter(_from) {
        require(tokenIds.current() >= _tokenId, "Tool does not exist");
        require(tools[_tokenId].isAvailable, "Tool is not available");

        setUser(_tokenId, _to, _expires);
        emit UpdateDelegation(_tokenId, _to, _expires);
}
    
}


   
 
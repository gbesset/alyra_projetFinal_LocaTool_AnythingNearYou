// SPDX-License-Identifier: MIT
pragma solidity 0.8.19;

import "./ERC4907.sol";
import "./IAnyNFTCollection.sol";
import "../node_modules/@openzeppelin/contracts/utils/Counters.sol";
import "../node_modules/@openzeppelin/contracts/access/Ownable.sol";
import "./Utils.sol";

contract AnyNFTCollection is ERC4907, IAnyNFTCollection, Ownable{

    using Counters for Counters.Counter;

    Counters.Counter private tokenIds;

    // Factory that deploy the collection (AnyRental contract)
    address public factory;

    // NFTs in collection generated by the renter and max
    Utils.Tool[]  tools;

    uint8 public constant MAX_TOOLS = 100;

    constructor(string memory _name, string memory _symbol) ERC4907(_name,_symbol){

        // Fill the first element of tools to match NFT tokenId that starts at 1
        Utils.Tool memory _tool0;
        _tool0.tokenID = 0;
        _tool0.serialID = 0;
        _tool0.title = "genesis";
        _tool0.description = "genesis";
        _tool0.tokenURI = "";
        _tool0.isAvailable = false; 
        tools.push(_tool0);
    }



/* ***********************************************
*   Events 
*********************************************** */
  /**
     * @dev Emitted when a renter add a tool to its NFT Collection.
     */
    event NFTCreated(address owner, uint tokenId, uint timestamp);
  
 /**
     * @dev Emitted when a renter add a tool to its NFT Collection.
     */
    event NFTBurned(address owner, uint tokenId, uint timestamp);
  


/* ***********************************************
*   Modifiers 
*********************************************** */
    /**
    * @dev Only owner is authorised :
    *    - if he is the msg.sender
    *    - if he is the msg.sender throw the factory that deployed
    */
    modifier onlyOwnerOrOwnerThrowFactory(address _from) {
        require(owner()==msg.sender || (owner()==_from &&  factory==msg.sender), "You are not the owner of that collection.");
        _;
    }
 
/* ***********************************************
*   setter / Getters 
*********************************************** */

function setFactoryAddress(address _factoryAuthorized) external onlyOwner{
        factory = _factoryAuthorized;
    }


    function getTools() public view returns (Utils.Tool[] memory){
        return tools;
    }

    function getToolsByTokenID(uint _tokenId) public view returns (Utils.Tool memory){
        require(tokenIds.current() >= _tokenId, "Tool does not exist");
        for (uint i; i < tools.length; i++) {
            if(tools[i].tokenID == _tokenId){
                return tools[i];
            }
        }
        return tools[0];
    }

     function getNbTools() public view returns (uint){
        return tools.length;
    }

/* ***********************************************
*    mint / burn / rent / giveBack
*********************************************** */
   
    /**
    * @notice mint a tool NFT and add it to the array
    * @dev
    * Requirements: tokenURI, title and description can't be empty.
    * @return tokenIdof the token
    */
   function mint(string calldata _tokenURI, uint _serialId, string memory _title, string memory _description, address _from) external onlyOwnerOrOwnerThrowFactory(_from)  returns (uint256) {
        require(tools.length < MAX_TOOLS, "Maximum number of tools reached");
        require(!Utils.isEqualString(_tokenURI,""), "token URI can't be empty");
        require(!Utils.isEqualString(_title,""), "title can't be empty");
        require(!Utils.isEqualString(_description,""), "description can't be empty");

        tokenIds.increment();
        uint newToolId = tokenIds.current();

         Utils.Tool memory _tool;
        _tool.tokenID = newToolId;
        _tool.serialID = _serialId;
        _tool.title = _title;
        _tool.description = _description;
        _tool.tokenURI = _tokenURI;
        _tool.isAvailable = true; 

        tools.push(_tool);


        _mint(owner(), newToolId);
        _setTokenURI(newToolId, _tokenURI);

        emit NFTCreated(owner(),newToolId, block.timestamp );
        return newToolId;
    }


   
    function burn(uint256 _tokenId, address _from) external onlyOwnerOrOwnerThrowFactory(_from) {
        require(_exists(_tokenId), "Token ID does not exist");
        require(tokenIds.current() >= _tokenId, "Tool does not exist");

        uint id;
         for (uint i; i < tools.length; i++) {
            if(tools[i].tokenID == _tokenId){
                id=i;
                break;
            }
        }
        
        //delete tools[id];   
        tools[id] = tools[tools.length-1];
        tools.pop();
        _burn(_tokenId);
        emit NFTBurned(owner(), _tokenId, block.timestamp );
    }


    function rentTool(uint _tokenId, address _to, uint64 _expires, address _from) external onlyOwnerOrOwnerThrowFactory(_from) {
        require(tokenIds.current() >= _tokenId, "Tool does not exist");
        require(tools[_tokenId].isAvailable, "Tool is not available");

        setUser(_tokenId, _to, _expires);
        emit UpdateDelegation(_tokenId, _to, _expires);
}
    
}


   
 
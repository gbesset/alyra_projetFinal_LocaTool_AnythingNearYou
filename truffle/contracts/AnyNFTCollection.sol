// SPDX-License-Identifier: MIT
pragma solidity 0.8.19;

//import "./ERC4907.sol";
import "../node_modules/@openzeppelin/contracts/utils/Counters.sol";
import "../node_modules/@openzeppelin/contracts/access/Ownable.sol";

import "../node_modules/@openzeppelin/contracts/token/ERC721/extensions/ERC721URIStorage.sol"; 
import "../node_modules/@openzeppelin/contracts/token/ERC721/ERC721.sol";


contract AnyNFTCollection is ERC721URIStorage, Ownable{

    using Counters for Counters.Counter;

    //TODO faire packaging variables
    struct Tool {
        uint serialID;
        string title;
        string description;
        bool isAvailable; //???
    }

    Counters.Counter private tokenIds;

    // Renter address allowed to mint NFTs
    address public renter;

    // NFTs in collection generated by the renter and max
    Tool[] public tools;
    uint256 public constant MAX_TOOLS = 100;

    constructor(string memory _name, string memory _symbol, address _owner) ERC721(_name,_symbol){
        renter = _owner;
    }



/* ***********************************************
*   Events 
*********************************************** */



/* ***********************************************
*   Modifiers 
*********************************************** */
    /**
    * @dev Only renter can call
    */
    modifier onlyRenter() {
        require(renter == msg.sender, "You are not the renter of that collection.");
        _;
    }
 
/* ***********************************************
*   Getters 
*********************************************** */


/* ***********************************************
*    mint / burn / rent / giveBack
*********************************************** */
   
    /**
    * @notice mint a tool NFT and add it to the array
    * @dev
    * Requirements: tokenURI, title and description can't be empty.
    * @return tokenIdof the token
    */
   function mint(string calldata _tokenURI, uint _serialId, string memory _title, string memory _description) external onlyRenter  returns (uint256) {
        require(tools.length < MAX_TOOLS, "Maximum number of tools reached");
        require(keccak256(abi.encode(_tokenURI)) != keccak256(abi.encode("")), "token URI can't be empty");
        require(keccak256(abi.encode(_title)) != keccak256(abi.encode("")), "title can't be empty");
        require(keccak256(abi.encode(_description)) != keccak256(abi.encode("")), "description can't be empty");

        tokenIds.increment();

        tools.push(Tool(_serialId, _title, _description, true));

        uint newToolId = tokenIds.current();
        _mint(renter, newToolId);
        _setTokenURI(newToolId, _tokenURI);

        return newToolId;
    }


   /* 
    function burn(uint256 _tokenId) external onlyRenter {
        _burn(_tokenId);
        for
    }*/


function rentTool(uint _toolId, address _to) external {
        require(tokenIds.current() >= _toolId, "Tool does not exist");
        require(tools[_toolId].isAvailable, "Tool is not available");

/*
        // Enregistrement des informations de location dans le mapping _users de ERC4907
        _users[tools[_toolId].owner].expires = end;
        _users[msg.sender].user = address(this);
        _users[msg.sender].expires = end;

        // Changement du propri√©taire de l'outil
        _tools[toolId].owner = msg.sender;
        _tools[toolId].isAvailable = false;

       // emit RentTool(toolId, dayPrice, caution, start, end, msg.sender);*/
    }
    


/* ***********************************************
*    extendRental / dispute 
*********************************************** */


}


   
 
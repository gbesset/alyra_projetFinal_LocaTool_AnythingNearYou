// SPDX-License-Identifier: MIT
pragma solidity 0.8.19;

import "./ERC4907.sol";
import "./IAnyNFTCollection.sol";
import "../node_modules/@openzeppelin/contracts/utils/Counters.sol";
import "../node_modules/@openzeppelin/contracts/access/Ownable.sol";
import "./Utils.sol";

contract AnyNFTCollection is ERC4907, IAnyNFTCollection, Ownable{

    using Counters for Counters.Counter;



    Counters.Counter private tokenIds;

    // Renter address allowed to mint NFTs
    address public renter;

    // NFTs in collection generated by the renter and max
    Utils.Tool[]  tools;
    uint nbTools;
    uint8 public constant MAX_TOOLS = 100;

    constructor(string memory _name, string memory _symbol, address _owner) ERC4907(_name,_symbol){
        renter = _owner;

        // Fill the first element of tools to match NFT tokenId
        Utils.Tool memory _tool0;
        tools.push(_tool0);
        nbTools=nbTools+1;
    }



/* ***********************************************
*   Events 
*********************************************** */
  /**
     * @dev Emitted when a renter add a tool to its NFT Collection.
     */
    event NFTCreated(address owner, uint tokenId, uint timestamp);
  


/* ***********************************************
*   Modifiers 
*********************************************** */
    /**
    * @dev Only renter can call
    */
    modifier onlyRenter(address _from) {
        require(renter == _from, "You are not the renter of that collection.");
        _;
    }
 
/* ***********************************************
*   Getters 
*********************************************** */
    function getTools() public view returns (Utils.Tool[] memory){
        return tools;
    }

    function getToolsByTokenID(uint _tokenId) public view returns (Utils.Tool memory){
        require(tokenIds.current() >= _tokenId, "Tool does not exist");
        return tools[_tokenId];
    }

     function getNbTools() public view returns (uint){
        return nbTools;
    }

/* ***********************************************
*    mint / burn / rent / giveBack
*********************************************** */
   
    /**
    * @notice mint a tool NFT and add it to the array
    * @dev
    * Requirements: tokenURI, title and description can't be empty.
    * @return tokenIdof the token
    */
   function mint(string calldata _tokenURI, uint _serialId, string memory _title, string memory _description, address _from) external onlyRenter(_from)  returns (uint256) {
        require(tools.length < MAX_TOOLS, "Maximum number of tools reached");
        require(!Utils.isEqualString(_tokenURI,""), "token URI can't be empty");
        require(!Utils.isEqualString(_title,""), "title can't be empty");
        require(!Utils.isEqualString(_description,""), "description can't be empty");

        tokenIds.increment();
        uint newToolId = tokenIds.current();

        tools.push(Utils.Tool(newToolId, _serialId, _title, _description, _tokenURI, true));
  
        nbTools=nbTools+1;

        _mint(renter, newToolId);
        _setTokenURI(newToolId, _tokenURI);

        //_from is the renter (cf modifiers)
        //To manage the delegation, _from delegate the approval to the contract
        //approve(msg.sender, newToolId);
        emit NFTCreated(renter,newToolId, block.timestamp );
        return newToolId;
    }


   
    function burn(uint256 _tokenId, address _from) external onlyRenter(_from) {
        delete tools[_tokenId];
        nbTools= nbTools -1;
        
        _burn(_tokenId);
    }


    function rentTool(uint _tokenId, address _to, uint64 _expires, address _from) external onlyRenter(_from) {
        require(tokenIds.current() >= _tokenId, "Tool does not exist");
        require(tools[_tokenId].isAvailable, "Tool is not available");

        setUser(_tokenId, _to, _expires);
        emit UpdateDelegation(_tokenId, _to, _expires);

/*
        // Enregistrement des informations de location dans le mapping _users de ERC4907
        _users[tools[_toolId].owner].expires = end;
        _users[msg.sender].user = address(this);
        _users[msg.sender].expires = end;

        // Changement du propri√©taire de l'outil
        _tools[toolId].owner = msg.sender;
        _tools[toolId].isAvailable = false;

       // emit RentTool(toolId, dayPrice, caution, start, end, msg.sender);*/
    }
    


/* ***********************************************
*    extendRental / dispute 
*********************************************** */


}


   
 